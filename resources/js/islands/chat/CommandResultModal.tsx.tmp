import React, { useState } from 'react'
import ReactMarkdown from 'react-markdown'
import remarkGfm from 'remark-gfm'
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from '@/components/ui/dialog'
import { Button } from '@/components/ui/button'
import { ScrollArea } from '@/components/ui/scroll-area'
import { SprintListModal } from '@/components/orchestration/SprintListModal'
import { SprintDetailModal } from '@/components/orchestration/SprintDetailModal'
import { TaskListModal } from '@/components/orchestration/TaskListModal'
import { TaskDetailModal } from '@/components/orchestration/TaskDetailModal'
import { AgentProfileGridModal } from '@/components/orchestration/AgentProfileGridModal'
import { BacklogListModal } from '@/components/orchestration/BacklogListModal'
import { TodoManagementModal } from '@/islands/chat/TodoManagementModal'
import { FragmentListModal } from '@/components/fragments/FragmentListModal'
import { ChannelListModal } from '@/components/channels/ChannelListModal'
import { RoutingInfoModal } from '@/components/routing/RoutingInfoModal'
import { AgentProfileDashboard } from '@/pages/AgentProfileDashboard'
import { AgentDashboard } from '@/pages/AgentDashboard'
import { TypeManagementModal } from '@/components/types/TypeManagementModal'
import { UnifiedListModal } from '@/components/unified/UnifiedListModal'
import { ProjectListModal } from '@/components/projects/ProjectListModal'
import { VaultListModal } from '@/components/vaults/VaultListModal'
import { BookmarkListModal } from '@/components/bookmarks/BookmarkListModal'

/**
 * Central registry mapping component names to React components.
 * All components must be registered here to be rendered by the command system.
 * 
 * Used by the config-driven routing system to dynamically render components
 * based on backend configuration.
 */
const COMPONENT_MAP: Record<string, React.ComponentType<any>> = {
  // List Components
  'SprintListModal': SprintListModal,
  'TaskListModal': TaskListModal,
  'AgentProfileGridModal': AgentProfileGridModal,
  'BacklogListModal': BacklogListModal,
  'ProjectListModal': ProjectListModal,
  'VaultListModal': VaultListModal,
  'BookmarkListModal': BookmarkListModal,
  'FragmentListModal': FragmentListModal,
  'ChannelListModal': ChannelListModal,
  
  // Detail Components
  'SprintDetailModal': SprintDetailModal,
  'TaskDetailModal': TaskDetailModal,
  
  // Generic Fallback
  'UnifiedListModal': UnifiedListModal,
  
  // Management Components
  'TodoManagementModal': TodoManagementModal,
  'TypeManagementModal': TypeManagementModal,
  'RoutingInfoModal': RoutingInfoModal,
  
  // Dashboard Components (will be renamed in Phase 3)
  'AgentProfileDashboard': AgentProfileDashboard,
  'AgentDashboard': AgentDashboard,
}

interface CommandResult {
  success: boolean
  type?: string
  component?: string
  data?: any
  message?: string
  error?: string
  fragments?: any[]
  shouldResetChat?: boolean
  shouldShowSuccessToast?: boolean
  toastData?: any
  config?: {
    type?: {
      slug?: string
      display_name?: string
      plural_name?: string
      storage_type?: string
      default_card_component?: string
      default_detail_component?: string
    }
    ui?: {
      modal_container?: string
      layout_mode?: string
      card_component?: string
      detail_component?: string
      filters?: any
      default_sort?: any
      pagination_default?: number
    }
    command?: {
      command?: string
      name?: string
      description?: string
      category?: string
    }
  }
}

interface CommandResultModalProps {
  isOpen: boolean
  onClose: () => void
  result: CommandResult | null
  command: string
}

/**
 * Transforms card component names to modal equivalents.
 * Convention: "XCard" → "XListModal"
 * 
 * @example
 * transformCardToModal("SprintCard") // "SprintListModal"
 * transformCardToModal("TaskCard")   // "TaskListModal"
 */
function transformCardToModal(cardName: string): string {
  if (cardName.endsWith('Card')) {
    return cardName.replace('Card', 'ListModal')
  }
  
  // Already a modal or unknown format - return as-is
  return cardName
}

/**
 * Determines which component to render based on backend config.
 * 
 * Config-Only Priority (NO LEGACY SUPPORT):
 * 1. config.ui.modal_container (explicit backend preference)
 * 2. config.ui.card_component (transformed to modal name)
 * 3. config.type.default_card_component (transformed)
 * 4. "UnifiedListModal" (fallback)
 * 
 * @param result - Command execution result with data and config
 * @returns Component name to render
 * 
 * @throws Never throws - always returns a valid component name
 */
function getComponentName(result: CommandResult): string {
  if (!result.config) {
    console.warn('[CommandResultModal] No config provided - using fallback')
    return 'UnifiedListModal'
  }
  
  // Priority 1: Explicit UI modal container
  if (result.config.ui?.modal_container) {
    console.log('[CommandResultModal] Using ui.modal_container:', 
      result.config.ui.modal_container)
    return result.config.ui.modal_container
  }
  
  // Priority 2: UI card component (transform)
  if (result.config.ui?.card_component) {
    const transformed = transformCardToModal(result.config.ui.card_component)
    console.log('[CommandResultModal] Transformed ui.card_component:', 
      result.config.ui.card_component, '→', transformed)
    return transformed
  }
  
  // Priority 3: Type default card component (transform)
  if (result.config.type?.default_card_component) {
    const transformed = transformCardToModal(result.config.type.default_card_component)
    console.log('[CommandResultModal] Transformed type.default_card_component:', 
      result.config.type.default_card_component, '→', transformed)
    return transformed
  }
  
  // Fallback
  console.log('[CommandResultModal] No component specified - using UnifiedListModal')
  return 'UnifiedListModal'
}

/**
 * Component handler interface for rendering functions
 */
interface ComponentHandlers {
  onClose: () => void
  onRefresh?: () => void
  executeDetailCommand?: (cmd: string) => void
}

/**
 * Builds standardized props for component rendering.
 * All components receive: isOpen, onClose, data, config
 * 
 * NO LEGACY PROPS - Only generic 'data' prop used.
 * 
 * @param result - Command execution result
 * @param componentName - Resolved component name
 * @param handlers - Event handlers (onClose, onRefresh, etc.)
 * @returns Props object ready for component
 */
function buildComponentProps(
  result: CommandResult,
  componentName: string,
  handlers: ComponentHandlers
): Record<string, any> {
  const { onClose, onRefresh, executeDetailCommand } = handlers
  
  // Base props (all components)
  const props: Record<string, any> = {
    isOpen: true,
    onClose,
    data: result.data,
    config: result.config,
  }
  
  // Add refresh handler if provided
  if (onRefresh) {
    props.onRefresh = onRefresh
  }
  
  // Add smart selection handlers based on component type
  if (executeDetailCommand) {
    if (componentName.includes('Sprint')) {
      props.onItemSelect = (item: any) => {
        executeDetailCommand(`/sprint-detail ${item.code}`)
      }
    } else if (componentName.includes('Task')) {
      props.onItemSelect = (item: any) => {
        executeDetailCommand(`/task-detail ${item.task_code}`)
      }
    } else if (componentName.includes('Agent')) {
      props.onItemSelect = (item: any) => {
        executeDetailCommand(`/agent-profile-detail ${item.slug}`)
      }
    }
  }
  
  // Add back handler for detail views
  if (componentName.includes('Detail')) {
    props.onBack = handlers.onClose
  }
  
  console.log('[CommandResultModal] Built props:', {
    componentName,
    propKeys: Object.keys(props),
    hasData: !!props.data,
    hasConfig: !!props.config,
  })
  
  return props
}

/**
 * Helper to identify where component name came from (for debugging)
 */
function getConfigSource(result: CommandResult): string {
  if (!result.config) return 'fallback'
  if (result.config.ui?.modal_container) return 'ui.modal_container'
  if (result.config.ui?.card_component) return 'ui.card_component (transformed)'
  if (result.config.type?.default_card_component) return 'type.default_card_component (transformed)'
  return 'fallback'
}

/**
 * Main component rendering function.
 * Handles resolution, lookup, fallback, and rendering.
 * 
 * NO SPECIAL CASES - All components are treated equally.
 * Components handle their own wrappers.
 * 
 * @param result - Command execution result
 * @param handlers - Event handlers
 * @returns Rendered React component or null
 */
function renderComponent(
  result: CommandResult,
  handlers: ComponentHandlers
): React.ReactNode {
  // Resolve component name from config
  const componentName = getComponentName(result)
  
  // Lookup in registry
  let Component = COMPONENT_MAP[componentName]
  
  if (!Component) {
    console.warn(`[CommandResultModal] Component "${componentName}" not found in registry`)
    console.warn('[CommandResultModal] Falling back to UnifiedListModal')
    Component = COMPONENT_MAP['UnifiedListModal']
  }
  
  // Build props
  const props = buildComponentProps(result, componentName, handlers)
  
  console.log('[CommandResultModal] Rendering component:', {
    componentName,
    hasComponent: !!Component,
    configSource: getConfigSource(result),
  })
  
  // Render component (no special cases, components handle their own wrappers)
  return <Component {...props} />
}

export function CommandResultModal({ 
  isOpen, 
  onClose, 
  result, 
  command 
}: CommandResultModalProps) {
  const [detailView, setDetailView] = useState<CommandResult | null>(null)
  const [isLoadingDetail, setIsLoadingDetail] = useState(false)

  if (!result) {
    return null
  }

  const handleBackToList = () => {
    console.log('CommandResultModal: Going back to list view')
    setDetailView(null)
  }

  const executeDetailCommand = async (detailCommand: string) => {
    console.log('Executing detail command:', detailCommand)
    setIsLoadingDetail(true)
    
    try {
      const csrf = (document.querySelector('meta[name="csrf-token"]') as HTMLMetaElement)?.content || ''
      const response = await fetch('/api/commands/execute', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-TOKEN': csrf
        },
        body: JSON.stringify({ command: detailCommand })
      })

      const detailResult = await response.json()
      
      if (detailResult.success) {
        console.log('Detail command result:', detailResult)
        setDetailView(detailResult)
      } else {
        console.error('Detail command failed:', detailResult)
        alert(detailResult.error || 'Failed to load details')
      }
    } catch (error) {
      console.error('Detail command execution failed:', error)
      alert('Failed to load details')
    } finally {
      setIsLoadingDetail(false)
    }
  }

  // Debug current state
  console.log('CommandResultModal render - detailView:', detailView, 'result.type:', result?.type)

  // Define handlers for component rendering
  const handlers: ComponentHandlers = {
    onClose,
    onRefresh: () => console.log('[CommandResultModal] Refresh requested'),
    executeDetailCommand,
  }
  // renderOrchestrationUI function removed - replaced with config-driven renderComponent()
      
      // Component routing based on component field
      switch (currentResult.component) {
        case 'SprintListModal':
          return (
            <SprintListModal
              isOpen={isOpen}
              onClose={() => {
                console.log('SprintListModal onClose called')
                handleBackToList()
                onClose()
              }}
              sprints={currentResult.data}
              onSprintSelect={(sprint) => {
                console.log('Sprint selected:', sprint)
                executeDetailCommand(`/sprint-detail ${sprint.code}`)
              }}
              onRefresh={() => {
                console.log('Refresh requested')
                alert('Refresh functionality not implemented yet.')
              }}
            />
          )
        case 'TaskListModal':
          return (
            <TaskListModal
              isOpen={isOpen}
              onClose={() => {
                console.log('TaskListModal onClose called')
                handleBackToList()
                onClose()
              }}
              tasks={currentResult.data}
              onTaskSelect={(task) => {
                console.log('Task selected:', task)
                executeDetailCommand(`/task-detail ${task.task_code}`)
              }}
              onRefresh={() => {
                console.log('Task refresh requested')
                alert('Task refresh functionality not implemented yet.')
              }}
            />
          )
        case 'AgentProfileDashboard':
          return (
            <Dialog open={isOpen} onOpenChange={onClose}>
              <DialogContent className="max-w-[95vw] h-[90vh] p-0">
                <AgentProfileDashboard initialAgents={currentResult.data} />
              </DialogContent>
            </Dialog>
          )
        case 'AgentDashboard':
          return (
            <Dialog open={isOpen} onOpenChange={onClose}>
              <DialogContent className="max-w-[95vw] h-[90vh] p-0">
                <AgentDashboard 
                  initialAgents={currentResult.data.agents} 
                  agentProfiles={currentResult.data.agentProfiles}
                />
              </DialogContent>
            </Dialog>
          )
        
        case 'AgentProfileListModal':
          return (
            <AgentProfileGridModal
              isOpen={isOpen}
              onClose={() => {
                console.log('AgentProfileGridModal onClose called')
                handleBackToList()
                onClose()
              }}
              agents={currentResult.data}
              onAgentSelect={(agent: any) => {
                console.log('Agent profile selected:', agent)
                executeDetailCommand(`/agent-profile-detail ${agent.slug}`)
              }}
              onRefresh={() => {
                console.log('Agent profile refresh requested')
                alert('Agent profile refresh functionality not implemented yet.')
              }}
            />
          )
        case 'BacklogListModal':
          return (
            <BacklogListModal
              isOpen={isOpen}
              onClose={() => {
                console.log('BacklogListModal onClose called')
                handleBackToList()
                onClose()
              }}
              tasks={currentResult.data}
              onTaskSelect={(task) => {
                console.log('Backlog task selected:', task)
                executeDetailCommand(`/task-detail ${task.task_code}`)
              }}
              onRefresh={() => {
                console.log('Backlog refresh requested')
                alert('Backlog refresh functionality not implemented yet.')
              }}
            />
          )
        case 'TodoManagementModal':
          return (
            <TodoManagementModal
              isOpen={isOpen}
              onClose={() => {
                console.log('TodoManagementModal onClose called')
                onClose()
              }}
            />
          )
        case 'TypeManagementModal':
          return (
            <TypeManagementModal
              isOpen={isOpen}
              onClose={() => {
                console.log('TypeManagementModal onClose called')
                onClose()
              }}
            />
          )
        case 'ProjectListModal':
          return (
            <ProjectListModal
              isOpen={isOpen}
              onClose={() => {
                console.log('ProjectListModal onClose called')
                onClose()
              }}
              projects={currentResult.data}
              onRefresh={() => {
                console.log('Project refresh requested')
              }}
            />
          )
        case 'VaultListModal':
          return (
            <VaultListModal
              isOpen={isOpen}
              onClose={() => {
                console.log('VaultListModal onClose called')
                onClose()
              }}
              vaults={currentResult.data}
              onRefresh={() => {
                console.log('Vault refresh requested')
              }}
            />
          )
        case 'BookmarkListModal':
          return (
            <BookmarkListModal
              isOpen={isOpen}
              onClose={() => {
                console.log('BookmarkListModal onClose called')
                onClose()
              }}
              bookmarks={currentResult.data}
              onRefresh={() => {
                console.log('Bookmark refresh requested')
              }}
            />
          )
        case 'UnifiedListModal':
          return (
            <UnifiedListModal
              isOpen={isOpen}
              onClose={() => {
                console.log('UnifiedListModal onClose called')
                onClose()
              }}
              data={currentResult.data}
              onRefresh={() => {
                console.log('UnifiedListModal refresh requested')
              }}
            />
          )
        case 'FragmentListModal':
          return (
            <FragmentListModal
              isOpen={isOpen}
              onClose={() => {
                console.log('FragmentListModal onClose called')
                onClose()
              }}
              fragments={currentResult.data}
              onFragmentSelect={(fragment) => {
                console.log('Fragment selected:', fragment)
                alert(`Fragment Navigation\n\nClicked: ${fragment.id}\n\nTask T-FRAG-NAV-01 required:\n- Navigate to chat session\n- Focus on fragment with ±5 context\n- Lazy loading`)
              }}
              onRefresh={() => {
                console.log('Fragment refresh requested')
                alert('Fragment refresh not implemented yet.')
              }}
            />
          )
        case 'ChannelListModal':
          return (
            <ChannelListModal
              isOpen={isOpen}
              onClose={() => {
                console.log('ChannelListModal onClose called')
                onClose()
              }}
              channels={currentResult.data}
              onChannelSelect={(channel) => {
                console.log('Channel selected:', channel)
                alert(`Channel: ${channel.name}\n\nChannel interaction coming soon.\nThis will allow joining/viewing channel details.`)
              }}
              onRefresh={() => {
                console.log('Channel refresh requested')
                alert('Channel refresh not implemented yet.')
              }}
            />
          )
        case 'RoutingInfoModal':
          return (
            <RoutingInfoModal
              isOpen={isOpen}
              onClose={() => {
                console.log('RoutingInfoModal onClose called')
                onClose()
              }}
              routingData={currentResult.data}
            />
          )
        case 'SprintDetailModal':
          return (
            <SprintDetailModal
              isOpen={isOpen}
              onClose={onClose}
              sprint={currentResult.data?.sprint}
              tasks={currentResult.data?.tasks || []}
              stats={currentResult.data?.stats || { total: 0, completed: 0, in_progress: 0, todo: 0, backlog: 0 }}
              onBack={isDetail ? handleBackToList : onClose}
              onTaskSelect={(task) => {
                console.log('Task selected from sprint detail:', task)
                executeDetailCommand(`/task-detail ${task.task_code}`)
              }}
            />
          )
        case 'TaskDetailModal':
          if (!currentResult.data?.task) {
            console.error('TaskDetailModal: No task data', currentResult)
            return (
              <Dialog open={isOpen} onOpenChange={onClose}>
                <DialogContent className="max-w-4xl rounded-sm">
                  <DialogHeader>
                    <DialogTitle className="text-foreground">Error</DialogTitle>
                  </DialogHeader>
                  <div className="p-4 text-center text-muted-foreground">
                    Task data not available. Please try again.
                  </div>
                </DialogContent>
              </Dialog>
            )
          }
          return (
            <TaskDetailModal
              isOpen={isOpen}
              onClose={onClose}
              task={currentResult.data.task}
              currentAssignment={currentResult.data?.current_assignment}
              assignments={currentResult.data?.assignments || []}
              content={currentResult.data?.content || {}}
              activities={currentResult.data?.activities || []}
              activitiesLoading={false}
              activitiesError={null}
              onBack={isDetail ? handleBackToList : onClose}
            />
          )
        case 'HelpModal':
          // For now, use the regular modal for help until we create HelpModal
          return null
        default:
          console.warn('Unknown component:', result.component)
          return null
      }
    }
    
    return null
  }

  // If we have a detail view, render it using new system
  if (detailView && detailView.success) {
    if (detailView.config) {
      return renderComponent(detailView, handlers)
    }
    // If detail view has no config (legacy/message response), show in regular modal
    if (detailView.message) {
      return (
        <Dialog open={isOpen} onOpenChange={onClose}>
          <DialogContent className="max-w-4xl max-h-[80vh] rounded-sm">
            <DialogHeader>
              <DialogTitle className="text-foreground">Details</DialogTitle>
            </DialogHeader>
            
            <ScrollArea className="max-h-[60vh] w-full rounded-sm border-0 bg-muted/20 p-3">
              <div className="prose prose-sm max-w-none text-foreground">
                <ReactMarkdown remarkPlugins={[remarkGfm]}>
                  {detailView.message}
                </ReactMarkdown>
              </div>
            </ScrollArea>
            
            <div className="flex justify-end gap-2">
              <Button variant="outline" onClick={handleBackToList} className="rounded-sm">
                Back
              </Button>
              <Button variant="outline" onClick={onClose} className="rounded-sm">
                Close
              </Button>
            </div>
          </DialogContent>
        </Dialog>
      )
    }
  }

  // If this has config, use new rendering system
  if (result.success && result.config) {
    return renderComponent(result, handlers)
  }

  const getTitle = () => {
    if (result.success) {
      return `Command: /${command}`
    } else {
      return `Command Failed: /${command}`
    }
  }

  const getContent = () => {
    if (!result.success) {
      return result.error || result.message || 'Command execution failed'
    }

    // For new PHP help command
    if (result.component === 'HelpModal' && result.data?.commands) {
      const commands = result.data.commands
      const helpContent = commands.map((cmd: any) => 
        `- **${cmd.usage}** – ${cmd.description}`
      ).join('\n')
      
      return `# Available Commands\n\n${helpContent}\n\n**Tip**: Most commands work with or without arguments. Try them out!`
    }

    // For commands with direct messages
    if (result.message) {
      return result.message
    }

    // For commands with fragments (like search results)
    if (result.fragments && result.fragments.length > 0) {
      const fragmentList = result.fragments.map((fragment, index) => 
        `**Fragment ${index + 1}:** ${fragment.message || fragment.content || 'No content'}`
      ).join('\n\n')
      
      return `Found ${result.fragments.length} result(s):\n\n${fragmentList}`
    }

    // Fallback for successful commands without specific content
    if (result.type === 'clear') {
      return 'Chat cleared successfully. The conversation history has been reset.'
    }
    
    return result.type === 'success' ? 'Command executed successfully' : `Command executed (type: ${result.type})`
  }

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-4xl max-h-[80vh] rounded-sm">
        <DialogHeader>
          <DialogTitle className="text-foreground">{getTitle()}</DialogTitle>
          {!result.success && (
            <DialogDescription className="text-muted-foreground">
              An error occurred while executing this command.
            </DialogDescription>
          )}
        </DialogHeader>
        
        <ScrollArea className="max-h-[60vh] w-full rounded-sm border-0 bg-muted/20 p-3">
          <div className="prose prose-sm max-w-none text-foreground">
            <ReactMarkdown 
              remarkPlugins={[remarkGfm]}
              components={{
                // Custom styling for help content
                h1: ({ children, ...props }) => (
                  <h1 className="text-lg font-bold mb-3 text-foreground" {...props}>
                    {children}
                  </h1>
                ),
                h2: ({ children, ...props }) => (
                  <h2 className="text-base font-semibold mb-2 mt-4 text-foreground" {...props}>
                    {children}
                  </h2>
                ),
                code: ({ children, ...props }) => (
                  <code className="bg-muted px-1 py-0.5 rounded-sm text-sm text-foreground" {...props}>
                    {children}
                  </code>
                ),
                pre: ({ children, ...props }) => (
                  <pre className="bg-muted p-2 rounded-sm overflow-x-auto text-foreground" {...props}>
                    {children}
                  </pre>
                ),
                ul: ({ children, ...props }) => (
                  <ul className="list-disc pl-4 mb-3 text-foreground" {...props}>
                    {children}
                  </ul>
                ),
                li: ({ children, ...props }) => (
                  <li className="mb-0.5 text-foreground" {...props}>
                    {children}
                  </li>
                ),
                p: ({ children, ...props }) => (
                  <p className="text-foreground mb-2" {...props}>
                    {children}
                  </p>
                ),
                strong: ({ children, ...props }) => (
                  <strong className="text-foreground font-semibold" {...props}>
                    {children}
                  </strong>
                ),
              }}
            >
              {getContent()}
            </ReactMarkdown>
          </div>
        </ScrollArea>
        
        <div className="flex justify-end gap-2">
          <Button variant="outline" onClick={onClose} className="rounded-sm">
            Close
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  )
}